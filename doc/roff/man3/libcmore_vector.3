.IX Title "VECTOR 3
.TH VECTOR 3 "May 2024" "libcmore v0.0.3" "vector"
.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.hy
.SS LIBRARY
.PP
C more library (libcmore, -lcmore)
.SS SYNOPSIS
.IP
.nf
\f[C]
typedef struct {

    int len;     //number of elements used
    size_t size; //number of elements allocated
    size_t data_size;
    cm_byte * data;

} cm_vector;


int cm_vector_get_val(cm_vector * vector, int index, cm_byte * buf);
cm_byte * cm_vector_get_ref(cm_vector * vector, int index);

int cm_vector_set(cm_vector * vector, int index, cm_byte * data);
int cm_vector_insert(cm_vector * vector, int index, cm_byte * data);
int cm_vector_append(cm_vector * vector, cm_byte * data);
void cm_vector_remove(cm_vector * vector, int index);
void cm_vector_empty(cm_vector * vector);

int cm_new_vector(cm_vector * vector, size_t data_size);
void cm_del_vector(cm_vector * vector);
\f[R]
.fi
.SS STRUCTURE
.PP
The \f[I]cm_vector\f[R] structure must be allocated before a pointer to
it can be passed to any function.
The \f[B]cm_new_vector()\f[R] function allocates and set members of the
\f[I]cm_vector\f[R] structure, not te structure itself.
.PP
The \f[I]len\f[R] member stores the length of the vector.
The \f[I]size\f[R] member stores the number of elements that can be held
by the currently allocated space for this vector.
When inserting or appending to a vector where
\f[I]len\f[R]==\f[I]size\f[R], the vector will automatically be
reallocated and \f[I]size\f[R] doubled.
\f[I]size\f[R] grows exponentially.
.PP
The \f[I]data_size\f[R] member stores the size in bytes of a single
element in the vector.
.PP
The \f[I]*data\f[R] member stores the allocation used by the vector for
storage.
It\[cq]s size is equal to \f[I]size\f[R] * \f[I]data_size\f[R].
.SS FUNCTIONS
.PP
The \f[B]cm_new_vector()\f[R] function takes a pointer to a vector
\f[I]*vector\f[R] and initialises it.
The initialised vector holds elements of size \f[I]data_size\f[R].
.PP
The \f[B]cm_del_vector()\f[R] function deinitialises a vector pointed to
by \f[I]*vector\f[R].
.PP
The \f[B]cm_vector_get_val()\f[R] function performs an equivalent
operation to \f[I]vector[index]\f[R], storing the result by value in the
buffer \f[I]*buf\f[R].
.PP
The \f[B]cm_vector_get_ref()\f[R] function returns a pointer to the
value stored at \f[I]vector[index]\f[R].
.PP
The \f[B]cm_vector_set()\f[R] function copies the contents of
\f[I]*data\f[R] to \f[I]vector[index]\f[R].
.PP
The \f[B]cm_vector_insert()\f[R] function inserts a new element with
value \f[I]*data\f[R] at \f[I]vector[index]\f[R].
This may cause a reallocation.
.PP
The \f[B]cm_vector_append()\f[R] function appends a new element with
value \f[I]*data\f[R] at the end of \f[I]*vector\f[R].
.PP
The \f[B]cm_vector_remove()\f[R] function removes an element at
\f[I]vector[index]\f[R].
.PP
The \f[B]cm_vector_empty()\f[R] empties the contents of
\f[I]*vector\f[R].
The memory is not overwritten.
.SS RETURN VALUE
.PP
The \f[B]cm_vector_get_ref()\f[R] function returns a pointer to the
value at \f[I]vector[index]\f[R] on success.
On error, NULL is returned.
All other functions return 0 on success or -1 on error.
On error, \f[I]cm_errno\f[R] is set.
See \f[B]libcmore_error\f[R]().
.SS EXAMPLES
.PP
See \f[I]src/test/vector.c\f[R] for examples.
.SS SEE ALSO
.PP
\f[B]libcmore_list\f[R](3), \f[B]libcmore_error\f[R](3)
