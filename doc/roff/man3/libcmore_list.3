.IX Title "LIST 3
.TH LIST 3 "May 2024" "libcmore v0.0.3" "list"
.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.hy
.SS LIBRARY
.PP
C more library (libcmore, -lcmore)
.SS SYNOPSIS
.IP
.nf
\f[C]
struct _cm_list_node {

    cm_byte * data;
    struct _cm_list_node * next;
    struct _cm_list_node * prev;

};
typedef struct _cm_list_node cm_list_node;

typedef struct {

    int len;
    size_t data_size;
    cm_list_node * head;

} cm_list;

int cm_list_get_val(cm_list * list, int index, cm_byte * buf);
cm_byte * cm_list_get_ref(cm_list * list, int index);
cm_list_node * cm_list_get_node(cm_list * list, int index);

cm_list_node * cm_list_set(cm_list * list, int index, cm_byte * data);
cm_list_node * cm_list_insert(cm_list * list, int index, cm_byte * data);
cm_list_node * cm_list_append(cm_list * list, cm_byte * data);
int cm_list_remove(cm_list * list, int index);
int cm_list_empty(cm_list * list);

void cm_new_list(cm_list * list, size_t data_size);
int cm_del_list(cm_list * list);
\f[R]
.fi
.SS STRUCTURE
.PP
The \f[I]cm_list\f[R] is a doubly-linked list consisting of
\f[I]cm_list_node\f[R] nodes.
The \f[I]cm_list\f[R] structure must be allocated before a pointer to it
can be passed to any function.
The \f[B]cm_new_list()\f[R] function allocates and set members of the
\f[I]cm_list\f[R] structure, not te structure itself.
.PP
The \f[I]len\f[R] member stores the number of nodes in the list.
.PP
The \f[I]data_size\f[R] member stores the size in bytes of a single
element in the list.
.PP
The \f[I]*head\f[R] member points to the first node,
\f[I]cm_list_node\f[R], in the list.
.SS FUNCTIONS
.PP
The \f[B]cm_new_list()\f[R] function takes a pointer to a list
\f[I]*list\f[R] and initialises it.
The initialised list holds nodes that store data of size
\f[I]data_size\f[R].
.PP
The \f[B]cm_del_list()\f[R] function deinitialises a list pointed to by
\f[I]*list\f[R].
.PP
The \f[B]cm_list_get_val()\f[R] function performs an equivalent
operation to \f[I]list[index]\f[R], storing the result by value in the
buffer \f[I]*buf\f[R].
.PP
The \f[B]cm_list_get_ref()\f[R] function returns a pointer to the value
stored at \f[I]list[index]\f[R].
.PP
The \f[B]cm_list_get_node()\f[R] function returns a pointer to a node at
\f[I]list[index]\f[R].
.PP
The \f[B]cm_list_set()\f[R] function copies the contents of
\f[I]*data\f[R] to \f[I]list[index]\f[R].
.PP
The \f[B]cm_list_insert()\f[R] function inserts a new element with value
\f[I]*data\f[R] at \f[I]list[index]\f[R].
This may cause a reallocation.
.PP
The \f[B]cm_list_append()\f[R] function appends a new element with value
\f[I]*data\f[R] at the end of \f[I]*list\f[R].
.PP
The \f[B]cm_list_remove()\f[R] function removes an element at
\f[I]list[index]\f[R].
.PP
The \f[B]cm_list_empty()\f[R] empties the contents of \f[I]*list\f[R].
The memory is not overwritten.
.SS RETURN VALUE
.PP
The \f[B]cm_list_get_ref()\f[R] function returns a pointer to the value
at \f[I]list[index]\f[R] on success.
On error, NULL is returned.
\f[B]cm_list_get_node()\f[R], \f[B]cm_list_set()\f[R],
\f[B]cm_list_insert()\f[R], and \f[B]cm_list_append()\f[R] return a
pointer to the node at \f[I]list[index]\f[R] on success.
On error, NULL is returned.
All other functions return 0 on success or -1 on error.
On error, \f[I]cm_errno\f[R] is set.
See \f[B]libcmore_error\f[R]().
.SS EXAMPLES
.PP
See \f[I]src/test/list.c\f[R] for examples.
.SS SEE ALSO
.PP
\f[B]libcmore_vector\f[R](3), \f[B]libcmore_error\f[R](3)
