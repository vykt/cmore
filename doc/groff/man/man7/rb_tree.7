.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "CMORE RED-BLACK TREE" "7" "Dec 2024" "CMore v1.0.0" "CMore Documentation"
.hy
.SH LIBRARY
.PP
The C More Library (\f[I]libcmore\f[R], \f[I]-lcmore\f[R])
.SH DESCRIPTION
.PP
The \f[B]CMore\f[R] \f[I]red-black tree\f[R] is a self balancing binary
sorted tree that maintains a guarantee of \f[B]O(log n)\f[R] for
traversal, insertion, and deletion.
The \f[I]red-black tree\f[R] is represented by a \f[V]cm_rb_tree\f[R]
structure.
It holds the size (in # of elements), the key size for each node (in
bytes), the data size for each node (in bytes), a pointer to the root
node, and a pointer to the \f[I]compare()\f[R] function that will be
covered shortly.
.PP
Each node in the \f[I]red-black tree\f[R] is represented by a
\f[V]cm_rb_tree_node\f[R] structure.
It consists of a pointer to an allocation storing the key for this node,
a pointer to an allocation storing the data for this node, a pointer to
a left node, a pointer to a right node, a pointer to a parent node,
whether this node is to the left or the right of its parent, represented
by a \f[V]cm_rb_tree_eval\f[R] enum, and a a colour for this node
represented by a \f[V]cm_r_tree_colour\f[R] enum.
.PP
Because a \f[I]red-black tree\f[R] is a sorted generic container, it
must call a user-specified \f[I]compare()\f[R] function.
This function accepts two parameters.
It must implement a comparison between these two parameters and return
\f[V]cm_rb_tree_eval\f[R] \f[V]LESS\f[R] if parameter one is less than
parameter two, \f[V]MORE\f[R] if parameter one is greater than parameter
two, and \f[V]EQUAL\f[R] if the parameters are equal, \f[V]EQUAL\f[R]
should be returned.
\f[I]compare()\f[R] is not allowed to return \f[V]ROOT\f[R].
Below is an example compare function:
.IP
.nf
\f[C]
enum cm_rb_tree_eval int_compare(void * arg1, void * arg2) {

    int num1 = *(int *) arg1;
    int num2 = *(int *) arg2;

    if (num1 > num2) return MORE;
    if (num1 < num2) return LESS;

    return EQUAL;
}
\f[R]
.fi
.PP
A \f[I]red-black tree\f[R] is created with \f[V]cm_new_rb_tree()\f[R].
This initialiser function does not allocate any memory.
A \f[I]red-black tree\f[R] is destroyed with \f[V]cm_del_rb_tree()\f[R].
A \f[I]red-black tree\f[R] can be emptied with
\f[V]cm_rb_tree_empty()\f[R]:
.IP
.nf
\f[C]
cm_rb_tree rb_tree;

//initialise the red-black tree
cm_new_rb_tree(&rb_tree, sizeof(int), sizeof(int), int_compare);

//empty the red-black tree
cm_rb_tree_empty(&tree);

//destroy the red-black tree
cm_del_rb_tree(&tree);
\f[R]
.fi
.PP
\f[V]cm_rb_tree_get_val()\f[R] gets the data at a key and copies it to a
buffer \f[V]buf\f[R].
\f[V]cm_rb_tree_get_ref()\f[R] returns a pointer to the data at a key.
\f[V]cm_rb_get_node()\f[R] returns the node at a key, allowing for
further traversal using the \f[V]left\f[R], \f[V]right\f[R], and
\f[V]parent\f[R] pointers.
If a key is not present in the \f[I]red-black tree\f[R], a
\f[I]CM_ERR_USER_KEY\f[R] error is stored in \f[V]cm_errno\f[R]:
.IP
.nf
\f[C]
cm_rb_tree rb_tree;
cm_rb_tree_node * node;
int ret, key, data, * data_ptr;

//initialise the red-black tree
cm_new_rb_tree(&rb_tree, sizeof(int), sizeof(int), int_compare);

//[populate the red-black tree]

//get the \[aq]2\[aq] key by value
key = 2;
ret = cm_rb_tree_get_val(&rb_tree, &key, &data);

//get a pointer to the \[aq]5\[aq] key
key = 5;
data_ptr = cm_rb_tree_get_ref(&rb_tree, &key);

//get the node of key \[aq]8\[aq]
key = 8;
node = cm_rb_tree_get_node(&rb_tree, &key);

//get the parent node of key \[aq]8\[aq]
if (node->parent_eval != ROOT) node = node->parent;
\f[R]
.fi
.PP
\f[V]cm_rb_tree_set()\f[R] assigns a value to a key.
If the key does not exist in the tree, a new node is created.
If the key already exists, it is overwritten.
\f[V]cm_rb_tree_remove()\f[R] removes a node with a matching key from
the \f[I]red-black tree\f[R].
\f[V]cm_rb_tree_unlink()\f[R] unlinks a node from the \f[I]red-black
tree\f[R].
All of these functions return a pointer to the node the operation was
performed on, with the exception of cm_rb_tree_remove().
In the case of \f[V]cm_rb_tree_unlink\f[R], the returned node must later
be freed with \f[V]cm_del_rb_tree_node()\f[R] to prevent a memory leak.
Requesting to remove or unlink a key that is not present in the
\f[I]red-black tree\f[R] will result in a \f[I]CM_ERR_USER_KEY\f[R]
error:
.IP
.nf
\f[C]
cm_rb_tree rb_tree;
cm_rb_tree_node * node;
int ret, key, data;

//initialise the red-black tree
cm_new_rb_tree(&rb_tree, sizeof(int), sizeof(int), int_compare);

//set a key
key = 2;
data = 20;
node = cm_rb_tree_set(&tree, &key, &data);

//set another key
key = 4;
data = 40;
node = cm_rb_tree_set(&tree, &key, &data);

//remove a key
key = 2;
ret = cm_rb_tree_remove(&tree, &key);

//unlink and free a node at key
key = 4;
node = cm_rb_tree_unlink(&tree, &key);
cm_del_rb_tree_node(node);

//destroy the red-black tree
cm_del_rb_tree(&tree);
\f[R]
.fi
.PP
On error, \f[I]NULL\f[R] or \f[I]-1\f[R] is returned depending on the
function.
See \f[B]CMore\f[R] \f[B]error\f[R] documentation to determine the
precise cause of an error.
