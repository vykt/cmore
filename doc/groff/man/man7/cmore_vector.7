.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "CMORE VECTOR" "7" "Dec 2024" "CMore v1.0.0" "CMore Documentation"
.hy
.SH LIBRARY
.PP
The C More Library (\f[I]libcmore\f[R], \f[I]-lcmore\f[R])
.SH DESCRIPTION
.PP
The \f[B]CMore\f[R] \f[I]vector\f[R] is a typical vector.
It is represented by a \f[V]cm_vector\f[R] structure.
It holds the size of one data element (in bytes), the length of the
\f[I]vector\f[R] (in # of elements), the current allocation size (in #
of elements), and a pointer to the allocation.
.PP
A \f[I]vector\f[R] is created by calling \f[V]cm_new_vector()\f[R].
This initialiser function does allocate memory.
The startin size of a \f[I]vector\f[R] allocation is \f[B]8\f[R].
A \f[I]vector\f[R] can be destroyed with cm_del_vector().
A \f[I]vector\f[R] may be emptied with \f[V]cm_vector_empty()\f[R].
.RS
.PP
int ret; cm_vector vector;
.PP
//initialise the vector ret = cm_new_vector(&vector, sizeof(int));
.PP
//destroy the vector cm_del_vector(&vector);
.RE
.PP
\f[V]cm_vector_get_val()\f[R] gets the data at an index and copies it to
a buffer \f[V]buf\f[R].
\f[V]cm_vector_get_ref()\f[R] returns a pointer to the data at an index.
Both positive and negative indeces can be used.
If an index is not in range, a \f[I]CM_ERR_USER_INDEX\f[R] error will be
stored in \f[I]cm_errno\f[R]:
.IP
.nf
\f[C]
cm_vector vector;
int ret, data, * data_ptr;

//initialise the vector
ret = cm_new_vector(&vector, sizeof(int));

//[populate the vector]

//get the second index by value
ret = cm_vector_get_val(&vector, 2, &data);

//get a pointer to third-to-last index
data_ptr = cm_vector_get_ref(&vector, -3);

//destroy the vector
cm_del_vector(&vector);
\f[R]
.fi
.PP
\f[V]cm_vector_set()\f[R] overrides the value at an index.
\f[V]cm_vector_insert()\f[R] inserts a value at the specified index.
\f[V]cm_vector_append()\f[R] inserts a value at the end of the
\f[I]vector\f[R].
.PP
When the length of a \f[I]vector\f[R] exceeds the allocated size, the
allocation doubles in size.
This means the size of the \f[I]vector\f[R] allocation grows
exponentially.
Removing elements from the \f[I]vector\f[R] or emptying it does not
reduce the size of the allocation.
The allocation of a \f[I]vector\f[R] can be set to its length by calling
\f[V]cm_vector_fit()\f[R].
Requesting to insert, set, or remove at an index that is out of range
will result in a \f[I]CM_ERR_USER_INDEX\f[R] error:
.IP
.nf
\f[C]
cm_vector vector;
int ret, data;

//initialise the vector
ret = cm_new_vector(&vector, sizeof(int));

//insert a value
data = 5;
int = cm_vector_insert(&vector, 0, &data);

//append a value
data = 3;
int = cm_vector_append(&vector, &data);

//overwrite the appended value
data = 10;
int = cm_vector_set(&vector, -1, &data);

//remove a value
ret = cm_vector_remove(&vector, 1);

//destroy the vector
cm_del_vector(&vector);
\f[R]
.fi
.PP
On error, \f[I]NULL\f[R] or \f[I]-1\f[R] is returned depending on the
function.
See \f[B]CMore\f[R] \f[B]error\f[R] documentation to determine the
precise cause of an error.
