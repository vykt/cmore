.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "CMORE LIST" "7" "Dec 2024" "CMore v1.0.0" "CMore Documentation"
.hy
.SH LIBRARY
.PP
The C More Library (\f[I]libcmore\f[R], \f[I]-lcmore\f[R])
.SH DESCRIPTION
.PP
The \f[B]CMore\f[R] \f[I]lst\f[R] is a doubly linked list.
A \f[I]lst\f[R] is represented by a \f[V]cm_lst\f[R] structure.
It holds the length of a \f[I]lst\f[R], the size (in bytes) of every
data element in a \f[I]lst\f[R] (\f[V]data_sz\f[R]), and a pointer to
the head of the \f[I]lst\f[R].
.PP
Each node in a list is represented by a \f[V]cm_lst_node\f[R] structure.
It consists of a next pointer, a previous pointer, and a pointer to an
allocation of size \f[V]data_sz\f[R] (in bytes) that stores the data for
this node.
.PP
A \f[I]lst\f[R] is created with \f[V]cm_new_lst()\f[R].
This initialiser function does not allocate any memory.
A \f[I]lst\f[R] is destroyed with \f[V]cm_del_lst()\f[R].
A \f[I]lst\f[R] may be emptied with \f[V]cm_list_emp()\f[R].
For example:
.IP
.nf
\f[C]
cm_list list;

//initialise the list
cm_new_list(&list, sizeof(int));

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
\f[V]cm_list_get()\f[R] gets the data at an index and copies it to a
buffer \f[V]buf\f[R].
\f[V]cm_list_get_p()\f[R] returns a pointer to the data at an index.
\f[V]cm_list_get_n()\f[R] returns the node at an index, allowing for
further traversal using the \f[V]next\f[R] and \f[V]prev\f[R] pointers.
.PP
Both positive and negative indeces can be used.
Specifying a negative index will cause a \f[I]lst\f[R] to be traversed
using the \f[V]prev\f[R] pointers.
Specifying an index that would cause the \f[I]lst\f[R] traversal to
perform a loop will result in a \f[I]CM_ERR_USER_INDEX\f[R] error:
.IP
.nf
\f[C]
cm_lst list;
cm_lst_node * node;
int ret, data, * data_ptr;

//initialise the list
cm_new_list(&list, sizeof(int));

//[populate the list]

//get the second index by value
ret = cm_list_get_val(&list, 2, &data);

//get a pointer to second-to-last index
data_ptr = cm_list_get_ref(&list, -2);

//get a pointer to the third index\[aq]s node
node = cm_list_get_node(&list, 3);

//get a pointer to the fourth index\[aq]s node
node = node->next;

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
Performing operations on a \f[I]lst\f[R] can be done using either an
index or a pointer to a node.
\f[V]cm_list_set()\f[R] overwrites the value at an index.
\f[V]cm_list_set_n()\f[R] overwrites the value of the provided node.
\f[V]cm_list_ins()\f[R] inserts a value at the specified index.
\f[V]cm_list_ins_nb()\f[R] inserts a value before the provided node.
\f[V]cm_list_ins_na()\f[R] inserts a value after the provided
node\f[V].\f[R]cm_list_apd()\[ga] inserts a value at the end of the
\f[I]lst\f[R].
\f[V]cm_list_rmv()\f[R] removes a value at an index from the
\f[I]lst\f[R].
\f[V]cm_list_rmv_n()\f[R] removes the provided node from the
\f[I]lst\f[R].
\f[V]cm_list_uln()\f[R] unlinks a node at an index from the
\f[I]lst\f[R].
\f[V]cm_list_uln_n()\f[R] unlinks the provided node from the
\f[I]lst\f[R].
All of these functions return a pointer to the node the operation was
performed on for convenience, with the exceptions of
\f[V]cm_list_rmv()\f[R] and \f[V]cm_list_rmv_n()\f[R].
In the case of \f[V]cm_list_uln()\f[R] and \f[V]cm_list_uln_n()\f[R],
the returned node must later be freed with \f[V]cm_del_lst_node()\f[R]
to prevent a memory leak.
Requesting to insert, set, remove, or unlink at an index that is out of
range will result in a \f[I]CM_ERR_USER_KEY\f[R] error:
.IP
.nf
\f[C]
cm_lst list;
cm_lst_node * node;
int ret, data;

//initialise the list
cm_new_list(&list, sizeof(int));

//insert a value by index: [5]
data = 5;
node = cm_list_ins(&list, 0, &data);

//insert before the \[aq]node\[aq] pointer: [7, 5]
data = 7;
node = cm_list_ins_nb(&list, node, &data);

//insert after the \[aq]node\[aq] pointer: [7, 9, 5]
data = 9;
node = cm_list_ins_na(&list, node, &data);

//append a value: [7, 9, 5, 3]
data = 3;
node = cm_list_apd(&list, &data);

//overwrite the appended value by index: [7, 9, 5 ,-3]
data = -3;
node = cm_list_set(&list, -1, &data);

//overwrite the second node with its pointer: [7, -9, 5 ,-3]
data = -9;
node = cm_list_set_n(&list, list.head->next, &data);

//remove a value bu index: [7, 5, -3]
ret = cm_list_rmv(&list, 1);

//remove a value by pointer: [5, -3]
node = cm_list_rmv_n(&list, list.head);

//unlink a node by index and free it: [-3]
node = cm_list_uln(&list, 0);
cm_del_lst_node(node);

//inlink a node with its pointer and free it:
node = cm_list_uln_n(&list, list.head);
cm_del_lst_node(node);

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
On error, \f[I]NULL\f[R] or \f[I]-1\f[R] is returned depending on the
function.
See \f[B]CMore\f[R] \f[B]error\f[R] documentation to determine the
precise cause of an error.
