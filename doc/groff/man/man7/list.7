.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "CMORE LIST" "7" "Dec 2024" "CMore v1.0.0" "CMore Documentation"
.hy
.SH LIBRARY
.PP
The C More Library (\f[I]libcmore\f[R], \f[I]-lcmore\f[R])
.SH DESCRIPTION
.PP
The \f[B]CMore\f[R] \f[I]list\f[R] is a doubly linked list.
A \f[I]list\f[R] is represented by a \f[V]cm_list\f[R] structure.
It holds the length of a \f[I]list\f[R], the size (in bytes) of every
data element in a \f[I]list\f[R] (\f[V]data_size\f[R]), and a pointer to
the head of the \f[I]list\f[R].
.PP
Each node in a list is represented by a \f[V]cm_list_node\f[R]
structure.
It consists of a next pointer, a previous pointer, and a pointer to an
allocation of size \f[V]data_size\f[R] (in bytes) that stores the data
for this node.
.PP
A \f[I]list\f[R] is created with \f[V]cm_new_list()\f[R].
This initialiser function does not allocate any memory.
A list is destroyed with \f[V]cm_del_list()\f[R].
A \f[I]list\f[R] may be emptied with \f[V]cm_list_empty()\f[R].
For example:
.IP
.nf
\f[C]
cm_list list;

//initialise the list
cm_new_list(&list, sizeof(int));

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
\f[V]cm_list_get_val()\f[R] gets the data at an index and copies it to a
buffer \f[V]buf\f[R].
\f[V]cm_list_get_ref()\f[R] returns a pointer to the data at an index.
\f[V]cm_list_get_node()\f[R] returns the node at an index, allowing for
further traversal using the \f[V]next\f[R] and \f[V]prev\f[R] pointers.
.PP
Both positive and negative indeces can be used.
Specifying a negative index will cause the \f[I]list\f[R] to be
traversed using the \f[V]prev\f[R] pointers.
Specifying an index that would cause the \f[I]list\f[R] traversal to
perform a loop will result in a \f[I]CM_ERR_USER_INDEX\f[R] error:
.IP
.nf
\f[C]
cm_list list;
cm_list_node * node;
int ret, data, * data_ptr;

//initialise the list
cm_new_list(&list, sizeof(int));

//[populate the list]

//get the second index by value
ret = cm_list_get_val(&list, 2, &data);

//get a pointer to second-to-last index
data_ptr = cm_list_get_ref(&list, -2);

//get a pointer to the third index\[aq]s node
node = cm_list_get_node(&list, 3);

//get a pointer to the fourth index\[aq]s node
node = node->next;

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
\f[V]cm_list_set()\f[R] overwrites the value at an index.
\f[V]cm_list_insert()\f[R] inserts a value at the specified index.
\f[V]cm_list_append()\f[R] inserts a value at the end of the
\f[I]list\f[R].
\f[V]cm_list_remove()\f[R] removes a value from the list.
\f[V]cm_list_unlink()\f[R] unlinks a node from the tree.
All of these functions return a pointer to the node the operation was
performed on for convenience, with the exception of
\f[V]cm_list_remove()\f[R].
In the case of \f[V]cm_list_unlink()\f[R], the returned node must later
be freed with \f[V]cm_del_list_node()\f[R] to prevent a memory leak.
Requesting to insert, set, remove, or unlink at an index that is out of
range will result in a \f[I]CM_ERR_USER_KEY\f[R] error:
.IP
.nf
\f[C]
cm_list list;
cm_list_node * node;
int ret, data;

//initialise the list
cm_new_list(&list, sizeof(int));

//insert a value
data = 5;
node = cm_list_insert(&list, 0, &data);

//append a value
data = 3;
node = cm_list_append(&list, &data);

//overwrite the appended value
data = 10;
node = cm_list_set(&list, -1, &data);

//remove a value
ret = cm_list_remove(&list, 1);

//unlink and free a node
node = cm_list_unlink(&list, 0);
cm_del_list_node(node);

//destroy the list
cm_del_list(&list);
\f[R]
.fi
.PP
On error, \f[I]NULL\f[R] or \f[I]-1\f[R] is returned depending on the
function.
See \f[B]CMore\f[R] \f[B]error\f[R] documentation to determine the
precise cause of an error.
